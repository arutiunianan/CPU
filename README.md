# Анишкин CPU
## Что он делает?
ASM преобразует команды на моем ассемблер-языке в их байт-коды.

CPU выполняет любые программы, которые представлены в его байт-коде.

DIS преобразует байт-коды программы на команды на моем ассемблер-языке.

### Команды
Мой ассемблер-язык обрабатывает такой список команд:

| Имя команды | Код команды | Описание | Количество аргументов(их тип) |
|-------------|-------------|----------|-------------------------------|
| HLT         | 0           | Прекращает работу программы| 0 |
| PUSH        | 1           | Кладет в stack введенное в качестве аргумента значение или число, находящееся в агрумент-регистре | 1(IMM/REG) |
| POP         | 2           | Достает последнее значение из stack и кладет его в агрумент-регистр | 1(REG) |
| ADD         | 3           | Достает два последних значения из stack и результат их суммирования кладет в stack| 0 |
| MUL         | 4           | Достает два последних значения из stack и результат их произведения кладет в stack| 0 |
| SUB         | 5           | Достает последнее и предпоследнее значения из stack, отнимает из первого второе и результат кладет в stack | 0 |
| DIV         | 6           | Достает последнее и предпоследнее значения из stack, делит первое на второе и результат кладет в stack | 0 |
| SQRT        | 7           | Достает последнее значение из stack и его квадрат кладет в stack| 0 |
| OUT         | 9           | Достает и выводит последнее значение из stack в консоль | 0 |
| IN          | 10           | Считывает значение из консоли и кладет в stack | 0 |
| JMP         | 12          | Прыгает на функцию, название которой содержится в качестве аргумента | 1(LAB) |
| JA          | 13          | Достает последнее и предпоследнее значения из stack, если первое больше второго, выполняется команда JMP | 1(LAB) |
| JB          | 14          | Достает последнее и предпоследнее значения из stack, если первое меньше второго, выполняется команда JMP | 1(LAB) |
| JAE         | 15          | Достает последнее и предпоследнее значения из stack, если первое не меньше второго, выполняется команда JMP | 1(LAB) |
| JBE         | 16          | Достает последнее и предпоследнее значения из stack, если первое не больше второго, выполняется команда JMP | 1(LAB) |
| JE          | 17          | Достает два последних значения из stack, если они равны, выполняется команда JMP | 1(LAB) |
| JNE         | 18          | Достает два последних значения из stack, если они не равны, выполняется команда JMP | 1(LAB) |
| CALL        | 19          | Кладет в stack номер текущей строки и выполняет команду JMP | 1(LAB) |
| RET         | 20          | Достает значение из stack и прыгает на строку с таким номером | 0 |

### Регистры
Мой ассемблер-язык распознает такой набор регистров:

| Имя регистра | Код регистра | Имя регистра | Код регистра |
|-------------|-------------|----------|-------------------------------|
| RAX | 1 | RBX | 2 |
| RCX | 3 | RDX | 4 |
| RSP | 5 | RBP | 6 |
| RSI | 7 | RDI | 8 |

## Какой принцип работы?
#### ASM
Программа принимает на вход файл с набором инструкций. Они должны содержать команды строго из первой таблицы. Каждая инструкция записывается в бит-код по такой схеме:

<image src="for_readme/instruction.jpeg" width=650px>

Первые три бита занимают тип аргумента. Если аргумент соответствует какому-то типу, то в определенное место исходя схеме кладется единица, а остальные два бита обнуляются. Если же аргумента нет, то все три бита обнуляются. 

Следующие пять битов соответствуют коду команды из таблицы.

Последние восемь бит занимает значение аргумента. Их может занимать число, номер строки функции, код регистра из таблицы выше и нуль, если аргумента нет.

<b>Например:</b>

PUSH 3

Тип аргумента IMM,  код команды PUSH - 1, аргумент - 3

001 00001 00000011(если тип аргумента int)

Далее бит-код каждой инструкции записывается в файл по-очереди друг за другом.

#### CPU
Программа принимает на вход файл с бит-кодами. Процесс обработки инструкций обратный ASM'у. Далее выполняется определенная команда.

<b>Например:</b>

01000010 00000010(если тип аргумента int)

Тип аргумента REG,  команда с кодом 2 - POP, регистр с кодом 2 - RBX.

В соответствии первой таблицы из stack'а достается последний элемент и кладется в регистр RBX.

#### DIS
Принцип работы абсолютно противоположен ASM. Программа, как и в случае с CPU, принимает на вход файл с бит-кодами. Поочередно считывается каждая инструкция и переводится в строку с названием команды и его аргументом, если он имеется.

<b>Например:</b>

00001010 00000000

Аргумента нет,  команда с кодом 10 - IN.

IN

## Как запустить программу?

Для компиляции ASM, CPU и DIS соотвественно:

```
make asm
make cpu
make dis
```

Для запуска каждой из программ:

```
./asm_ <ассемблер-файл> <бит-код-файл>
./cpu_ <бит-код-файл>
./dis_ <бит-код-файл> <ассемблер-файл>
```
Если не вводить названия файлов, то будут использоваться файлы по-умолчанию.

## Как выглядит результат работы программ?
Для решения квадратного уравнения написала [ассемблер-код](quadratic_equation.txt).

ASM составляет по ней [бит-код](ass.txt) всему ассемблер-коду.

CPU выполняет команды из файла - результата работы ASM:

<image src="for_readme/cpu1.jpeg" width=250px>
<image src="for_readme/cpu2.jpeg" width=250px>
<image src="for_readme/cpu3.jpeg" width=250px>
<image src="for_readme/cpu4.jpeg" width=250px>
<image src="for_readme/cpu5.jpeg" width=250px>

DIS составляет [ассемблер-код](dis/dis.txt) из бит-кода.